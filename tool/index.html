<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Dark Mode Bezier Layout - Image Processing</title>
<style>
:root{--bg:#0b0f13;--panel:#0f1720;--muted:#94a3b8;--accent:#60a5fa;--inactive-flow:#475569;--active-flow:#facc15;}
*{box-sizing:border-box}
body{
  margin:0;
  padding:20px;
  font-family:Inter,sans-serif;
  background:linear-gradient(180deg,var(--bg),#061018 120%);
  color:var(--muted);
  display:flex;
  justify-content:center;
  min-height: 100vh;
}
.container{max-width:1100px;width:100%}
.card{
  background:linear-gradient(180deg,var(--panel),#0b1220);
  border-radius:12px;
  padding:16px;
  width: 100%;
}
/* Increased vertical spacing */
.top-wrap{display:flex;justify-content:center;margin:40px 0}
.three-row{position:relative;margin:60px 0}
.row{display:flex;gap:12px;justify-content:space-between}
.bottom-row{margin-top:40px}

/* Node Styling */
.rect,.node{
  width:260px;
  max-width: 31%;
  aspect-ratio:3/2;
  border-radius:12px;
  background:#1e293b;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
  position:relative;
  transition:box-shadow 0.3s;
  flex-shrink: 1;
}
/* Only apply blue border if manually uploaded (controlled by JS toggling this class) */
.rect.uploaded,.node.uploaded{box-shadow:0 0 0 4px rgba(96,165,250,0.6)}

/* Placeholder Text and Visuals */
.placeholder-text {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none; /* Managed by JS */
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: var(--inactive-flow); /* gray */
  font-size: 14px;
  font-weight: 600;
  text-align: center;
  padding: 10px;
  background: #1e293b;
  z-index: 5;
  pointer-events: none;
}
.placeholder-text::after {
    content: "\A Upload or Process Image";
    white-space: pre;
    font-weight: 400;
    font-size: 12px;
    margin-top: 5px;
    color: var(--inactive-flow);
}
.rect.empty .placeholder-text, .node.empty .placeholder-text {
    display: flex; /* Show placeholder when node is 'empty' */
}
.rect img, .node img {
    /* Image element is controlled by the 'empty' class */
    display: none; 
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: relative;
    z-index: 10;
}
.rect:not(.empty) img, .node:not(.empty) img {
    display: block; /* Show image only if not empty */
}


/* Buttons */
.upload-btn,.trash-btn,.save-btn{
  position:absolute;
  border:none;
  border-radius:4px;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  font-size:14px;
  z-index:15; /* Ensure buttons are above images/placeholders */
  transition: transform 0.1s, opacity 0.2s;
}
.upload-btn:active, .trash-btn:active, .save-btn:active {
    transform: scale(0.95);
}

.upload-btn{top:4px;left:4px;width:28px;height:28px;background:rgba(96,165,250,0.85);color:#fff}
.trash-btn{top:4px;right:4px;width:28px;height:28px;background:rgba(248,113,113,0.85);color:#fff}

/* Flow Update Button (External to Node) - Always visible, state controlled by class */
.update-btn{
  position:absolute;
  width: 32px; /* Slightly larger for visibility on path */
  height: 32px;
  color:#000;
  border-radius:50%; /* Make it round */
  display:flex; 
  align-items:center;
  justify-content:center;
  font-size: 16px;
  padding: 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.4);
  z-index: 20; /* Ensure it's above the SVG */
  border: 3px solid var(--bg); /* Outline to stand out from the path */
  transition: background-color 0.2s, opacity 0.2s, transform 0.1s;
  cursor: pointer;
}
.update-btn.inactive {
  background-color: var(--inactive-flow);
  opacity: 0.6;
  cursor: default;
}
.update-btn:not(.inactive) {
  background-color: var(--active-flow);
  opacity: 1;
}
.update-btn:not(.inactive):hover {
    transform: scale(1.05);
}
.update-btn:not(.inactive):active {
    transform: scale(0.95);
}

.save-btn{bottom:4px;right:4px;width:28px;height:28px;background:rgba(34,197,94,0.85);color:#fff}

.three-row svg{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible;z-index: 1;}
input[type='file']{display:none}

/* Mobile Optimization */
@media (max-width: 768px) {
  body { padding: 8px; }
  .card { padding: 10px; }
  .top-wrap { margin: 16px 0; }
  .three-row { margin: 20px 0; }
  .bottom-row { margin-top: 16px; }
  
  .row { gap: 6px; }
  
  .upload-btn, .trash-btn, .save-btn { width: 24px; height: 24px; font-size: 12px; }
  .update-btn { width: 28px; height: 28px; font-size: 14px; }
  
  .rect, .node {
    border-radius: 8px;
    width: 32%; 
  }
}
</style>
</head>
<body>
<div class="container">
<div class="card">
<header><h1 style="color:var(--accent);font-size:16px;margin:0;text-align:center;">Image Processing Layout</h1></header>
<section class="top-wrap">
<div id="rootRect" class="rect empty"><div class="placeholder-text" data-text="ROOT IMAGE"></div><button class="upload-btn" title="Upload">ğŸ“¤</button><button class="trash-btn" title="Clear">ğŸ—‘ï¸</button><button class="save-btn" title="Save High-Res">ğŸ’¾</button><input type="file" accept="image/*"></div>
</section>
<section class="three-row" id="middleSection">
<svg id="linksSvg" aria-hidden="true"></svg>
<div class="row" id="topRow">
<div class="node empty" id="top1"><div class="placeholder-text" data-text="RED CHANNEL"></div><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="top2"><div class="placeholder-text" data-text="GREEN CHANNEL"></div><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="top3"><div class="placeholder-text" data-text="BLUE CHANNEL"></div><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
</div>
<div class="row bottom-row" id="bottomRow">
<div class="node empty" id="bot1"><div class="placeholder-text" data-text="RED GRAYSCALE"></div><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="bot2"><div class="placeholder-text" data-text="GREEN GRAYSCALE"></div><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="bot3"><div class="placeholder-text" data-text="BLUE GRAYSCALE"></div><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
</div>
</section>
</div>
</div>
<script>
(function(){
const svg=document.getElementById('linksSvg');
const middleSection = document.getElementById('middleSection');
const rootRect = document.getElementById('rootRect');
const allNodes=Array.from(document.querySelectorAll('.rect,.node'));
const topNodes=[document.getElementById('top1'),document.getElementById('top2'),document.getElementById('top3')];
const botNodes=[document.getElementById('bot1'),document.getElementById('bot2'),document.getElementById('bot3')];

// Store low-res canvases for display
let nodeCanvases={};
// Store original high-res files for saving
let originalFiles={};

function centerPoint(el){const rect=el.getBoundingClientRect();const parentRect=svg.getBoundingClientRect();return{x:rect.left+rect.width/2-parentRect.left,y:rect.top+rect.height/2-parentRect.top}}
function makePath(d){const p=document.createElementNS('http://www.w3.org/2000/svg','path');p.setAttribute('d',d);p.setAttribute('fill','none');p.setAttribute('stroke','rgba(96,165,250,0.85)');p.setAttribute('stroke-width','8');p.setAttribute('stroke-linecap','round');p.setAttribute('stroke-linejoin','round');return p}

// Function to update the placeholder text content based on the data-text attribute
function setPlaceholderText() {
    document.querySelectorAll('.placeholder-text').forEach(p => {
        const text = p.getAttribute('data-text');
        p.textContent = text;
    });
}

function getRelativeCenterCoords(sourceEl, targetEl) {
    const sRect = sourceEl.getBoundingClientRect();
    const tRect = targetEl.getBoundingClientRect();
    const containerRect = middleSection.getBoundingClientRect();
    const midY = (sRect.bottom + tRect.top) / 2;
    const targetEntryX = tRect.left + tRect.width / 2;
    
    const relativeX = targetEntryX - containerRect.left;
    const relativeY = midY - containerRect.top;

    return { x: relativeX, y: relativeY };
}

function createFlowButton(targetId, x, y) {
    const buttonId = `flow-${targetId}`;
    let button = document.getElementById(buttonId);

    if (!button) {
        button = document.createElement('button');
        button.className = 'update-btn';
        button.id = buttonId;
        button.dataset.targetId = targetId;
        button.title = targetId.startsWith('top') ? "Process Channel" : "Process Grayscale";
        button.innerHTML = 'â¬‡ï¸';
        middleSection.appendChild(button);
        button.addEventListener('click', handleUpdateClick);
    }
    
    // Position the button based on calculated midpoint, adjusted for button size (32px)
    button.style.cssText += `
        left: ${x - 16}px; /* Center horizontally (32/2 = 16) */
        top: ${y - 16}px;  /* Center vertically */
    `;
    
    // Initial visibility check based on current state
    updateFlowButtonState(targetId);
}

function updateFlowButtonState(targetId) {
    const buttonId = `flow-${targetId}`;
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    const targetEl = document.getElementById(targetId);
    
    let sourceReady = false;
    const targetEmpty = targetEl.classList.contains('empty');
    
    // Determine the source readiness
    if (targetId.startsWith('top')) {
        // Source is 'rootRect'
        sourceReady = !!nodeCanvases['rootRect'];
    } else if (targetId.startsWith('bot')) {
        // Source is corresponding 'top' node
        const botIdx = botNodes.findIndex(n => n.id === targetId);
        const sourceId = topNodes[botIdx]?.id;
        sourceReady = !!nodeCanvases[sourceId];
    }
    
    // Button is ACTIVE (yellow) if source is ready AND target is empty
    // Button is INACTIVE (gray) otherwise
    if (sourceReady && targetEmpty) {
        button.classList.remove('inactive');
    } else {
        button.classList.add('inactive');
        // If processing failed before and the error icon 'âŒ' is shown, replace it with the default 'â¬‡ï¸'
        if (button.innerHTML === 'âŒ' || button.innerHTML === 'âš™ï¸') {
             button.innerHTML = 'â¬‡ï¸';
        }
    }
}

function draw(){
    setPlaceholderText(); // Ensure placeholders are initialized

    // 1. Clear and redraw Bezier curves
    while(svg.firstChild)svg.removeChild(svg.firstChild);
    const container=document.getElementById('middleSection');
    const box=container.getBoundingClientRect();
    svg.setAttribute('width',box.width);
    svg.setAttribute('height',box.height);
    svg.style.width=box.width+'px';
    svg.style.height=box.height+'px';
    
    const root=document.getElementById('rootRect');
    const rootRect=root.getBoundingClientRect();
    const svgRect=svg.getBoundingClientRect();
    
    const rootX=(rootRect.left+rootRect.width/2)-svgRect.left;
    const rootY=(rootRect.top+rootRect.height)-svgRect.top;
    
    // --- Draw Paths & Place Buttons for Root -> Top Row ---
    topNodes.forEach(n=>{
        const c=centerPoint(n);
        const startX=rootX;
        const startY=rootY;
        const endX=c.x;
        const endY=c.y-(n.getBoundingClientRect().height/2);
        const cp1x=startX;
        const cp1y=startY+Math.max(30,box.height*0.1); 
        const cp2x=endX;
        const cp2y=endY-Math.max(30,box.height*0.1);
        const d=`M ${startX},${startY} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${endX},${endY}`;
        svg.appendChild(makePath(d));
        
        const coords = getRelativeCenterCoords(root, n);
        createFlowButton(n.id, coords.x, coords.y);
    });

    // --- Draw Paths & Place Buttons for Top Row -> Bottom Row ---
    for(let i=0;i<topNodes.length;i++){
        const topN = topNodes[i];
        const botN = botNodes[i];

        const topC=centerPoint(topN);
        const bC=centerPoint(botN);
        const startX=topC.x;
        const startY=topN.getBoundingClientRect().bottom-svgRect.top;
        const endX=bC.x;
        const endY=botN.getBoundingClientRect().top-svgRect.top;
        const offset=Math.max(10,(endY-startY)*0.2);
        const cp1x=startX;
        const cp1y=startY+offset;
        const cp2x=endX;
        const cp2y=endY-offset;
        const d=`M ${startX},${startY} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${endX},${endY}`;
        svg.appendChild(makePath(d));
        
        const coords = getRelativeCenterCoords(topN, botN);
        createFlowButton(botN.id, coords.x, coords.y);
    }
}

// Helper to clear a single node and update its flow state
function clearNode(nodeEl) {
    const rectId = nodeEl.id;
    const imgEl = nodeEl.querySelector('img');
    const input = nodeEl.querySelector('input[type=file]');

    imgEl.src = '';
    if (input) input.value = ''; // Only clear input if it exists
    
    nodeEl.classList.add('empty');
    nodeEl.classList.remove('uploaded');
    
    delete nodeCanvases[rectId];
    delete originalFiles[rectId];

    // Update flow button leading to this node
    updateFlowButtonState(rectId);
}

// Helper to update downstream flow button states
function updateDownstreamFlows(rectId) {
    if(rectId === 'rootRect'){
        // If root is modified/cleared, disable all top-row processing buttons
        // but do *not* clear the images themselves.
        topNodes.forEach(n => {
            updateFlowButtonState(n.id); 
            // Also update the buttons for the bottom row, as the ultimate source is now missing
            const topIdx = topNodes.indexOf(n);
            updateFlowButtonState(botNodes[topIdx].id);
        });
    } else {
        const topIdx = topNodes.findIndex(n => n.id === rectId);
        if (topIdx !== -1 && botNodes[topIdx]) {
            // Only update state for the downstream bot node
            updateFlowButtonState(botNodes[topIdx].id);
        }
    }
}

async function handleUpdateClick(e) {
    e.stopPropagation();
    const button = e.currentTarget;
    const targetId = button.dataset.targetId;
    const rect = document.getElementById(targetId);
    
    // Check if the button is active before proceeding
    if (button.classList.contains('inactive')) {
        return; 
    }
    
    // Find the source canvas
    let sourceCanvas = null;
    let isTopRow = false;
    let channelIdx = -1;
    
    if (targetId.startsWith('top')) {
        channelIdx = topNodes.findIndex(n => n.id === targetId);
        sourceCanvas = nodeCanvases['rootRect'];
        isTopRow = true;
    } else if (targetId.startsWith('bot')) {
        const botIdx = botNodes.findIndex(n => n.id === targetId);
        channelIdx = botIdx; 
        const sourceId = topNodes[botIdx]?.id;
        sourceCanvas = nodeCanvases[sourceId];
    }
    
    if(!sourceCanvas) return; // Should not happen due to inactive state check

    // Visual indication of work
    button.innerHTML = 'âš™ï¸'; 
    button.classList.add('inactive'); // Temporarily set inactive during processing
    
    const imgEl = rect.querySelector('img');
    let success = false;
    
    // Start processing (using low-res canvas)
    try {
        const ctx=sourceCanvas.getContext('2d');
        const imgData=ctx.getImageData(0,0,sourceCanvas.width,sourceCanvas.height);
        
        const newCanvas=document.createElement('canvas');
        newCanvas.width=sourceCanvas.width;
        newCanvas.height=sourceCanvas.height;
        const nctx=newCanvas.getContext('2d');
        const newData=nctx.createImageData(newCanvas.width,newCanvas.height);
        
        if (isTopRow) {
            // Process RGB Channels (R=0, G=1, B=2)
            for(let i=0;i<imgData.data.length;i+=4){
                newData.data[i+channelIdx]=imgData.data[i+channelIdx];
                // Zero out the other two channels
                if(channelIdx !== 0) newData.data[i]=0; 
                if(channelIdx !== 1) newData.data[i+1]=0;
                if(channelIdx !== 2) newData.data[i+2]=0;
                newData.data[i+3]=255; 
            }
        } else {
            // Process Grayscale (R=0, G=1, B=2) - Correctly use intensity of the specified channel only.
            const componentIndex = channelIdx; 
             for(let j=0;j<imgData.data.length;j+=4){
                // Use the intensity of the specific channel in the source image
                const intensity = imgData.data[j + componentIndex]; 
                
                newData.data[j] = intensity;   // New Red = Intensity
                newData.data[j+1] = intensity; // New Green = Intensity
                newData.data[j+2] = intensity; // New Blue = Intensity
                newData.data[j+3] = 255;       // Alpha
            }
        }

        nctx.putImageData(newData,0,0);
        
        // Use synchronous assignment
        imgEl.src = newCanvas.toDataURL();

        // Update the display element and state immediately.
        nodeCanvases[rect.id] = newCanvas;
        rect.classList.remove('empty'); 
        
        success = true;

    } catch (error) {
        console.error("Image processing failed:", error);
        button.innerHTML = 'âŒ'; // Show failure icon
    } finally {
        // Guarantee button reset and state update
        if (success) {
            button.innerHTML = 'â¬‡ï¸';
        }
        
        // Update state of the current flow button (targetId) and downstream nodes
        updateFlowButtonState(targetId);
        updateDownstreamFlows(targetId);
    }
}

function processHighResAndSave(file, type, channelIdx) {
    const reader = new FileReader();
    reader.onload = ev => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            
            // --- High-Res Processing Logic ---
            
            // 1. Apply Channel Filter (if applicable)
            if (type === 'channel' || type === 'both') {
                 // R=0, G=1, B=2
                for(let i=0; i<data.length; i+=4) {
                    if (channelIdx !== 0) data[i] = 0;
                    if (channelIdx !== 1) data[i+1] = 0;
                    if (channelIdx !== 2) data[i+2] = 0;
                    data[i+3] = 255;
                }
            }

            // 2. Apply Grayscale Filter (if applicable)
            if (type === 'grayscale' || type === 'both') {
                const componentIndex = (type === 'both') ? channelIdx : null;
                for(let i=0; i<data.length; i+=4) {
                    let intensity;
                    if (componentIndex !== null) {
                        // Channel Grayscale (e.g., Red Grayscale) - Uses only the specified channel intensity
                        intensity = data[i + componentIndex]; 
                    } else {
                        // Standard Grayscale (if processing a non-channel specific manual upload) - Uses average
                        intensity = (data[i] + data[i+1] + data[i+2]) / 3;
                    }
                    
                    data[i] = intensity;
                    data[i+1] = intensity;
                    data[i+2] = intensity;
                    data[i+3] = 255;
                }
            }

            ctx.putImageData(imgData, 0, 0);
            
            canvas.toBlob(blob => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `processed_highres_${Date.now()}.png`;
                a.click();
            }, 'image/png');
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
}

window.addEventListener('load',draw);
window.addEventListener('resize',()=>{if(window._drawRaf)cancelAnimationFrame(window._drawRaf);window._drawRaf=requestAnimationFrame(draw)});
setTimeout(draw,400);

allNodes.forEach(rect=>{
    const input=rect.querySelector('input[type=file]');
    const uploadBtn=rect.querySelector('.upload-btn');
    const trashBtn=rect.querySelector('.trash-btn');
    const saveBtn=rect.querySelector('.save-btn');
    
    // Create the persistent image element for display
    const imgEl=document.createElement('img');
    rect.appendChild(imgEl);
    
    uploadBtn?.addEventListener('click',e=>{e.stopPropagation();input.click()});
    
    input?.addEventListener('change',e=>{
        const file=e.target.files[0];
        if(!file)return;
        
        // Manual Upload gets the blue border
        rect.classList.add('uploaded');
        
        const reader=new FileReader();
        reader.onload=ev=>{
            // Use a temporary Image object to load and scale the high-res file
            const tempImg = new Image();
            tempImg.onload = () => {
                // Create low-res preview canvas
                const canvas=document.createElement('canvas');
                const ctx=canvas.getContext('2d');
                const maxW=400; 
                const scale=Math.min(maxW/tempImg.naturalWidth,maxW/tempImg.naturalHeight,1);
                canvas.width=tempImg.naturalWidth*scale;
                canvas.height=tempImg.naturalHeight*scale;
                ctx.drawImage(tempImg,0,0,canvas.width,canvas.height);
                
                // Set the display image (imgEl) to the low-res data URL.
                imgEl.src=canvas.toDataURL('image/jpeg',0.8);
                
                // Store original file and low-res canvas
                nodeCanvases[rect.id]=canvas;
                originalFiles[rect.id]=file;
                rect.classList.remove('empty'); // Image loaded, remove empty class
                
                // --- Cascade Updates on New Upload ---
                if(rect.id==='rootRect'){
                    // PER USER REQUEST: Do NOT clear generated nodes when a new root is uploaded.
                    // The images remain visually, but flow buttons are disabled by updateDownstreamFlows.
                    // We only clear nodes that were *generated* if they had been manually uploaded themselves.
                    topNodes.forEach(n => {
                        // If a node was manually uploaded, it keeps the uploaded class and its data
                        // Otherwise, we do nothing to keep the generated image displayed.
                    });
                    botNodes.forEach(n => {
                        // Same here.
                    });
                } else {
                    // If a top node is manually uploaded, clear its *generated* child (if any)
                    const topIdx = topNodes.findIndex(n => n.id === rect.id);
                    if (topIdx !== -1) {
                         // Only clear the generated data (botN) if it's currently generated (not a manual upload)
                         if (!botNodes[topIdx].classList.contains('uploaded')) {
                             clearNode(botNodes[topIdx]);
                         }
                    }
                }
                
                // Update flow button states based on new data availability
                updateFlowButtonState(rect.id);
                updateDownstreamFlows(rect.id);
            };
            tempImg.src = ev.target.result; // Start loading the image data in the temporary object
        };
        reader.readAsDataURL(file);
    });

    trashBtn?.addEventListener('click',e=>{
        e.stopPropagation();
        const rectId = rect.id;
        
        // 1. Clear the current node
        clearNode(rect);
        
        // 2. Cascade clear logic
        if(rectId === 'rootRect'){
            // PER USER REQUEST: Do NOT clear downstream images (topNodes, botNodes). 
            // The images remain visually, but flow buttons are disabled by updateDownstreamFlows.
            
        } else {
            const topIdx = topNodes.findIndex(n => n.id === rectId);
            const botIdx = botNodes.findIndex(n => n.id === rectId);

            if (topIdx !== -1) {
                 // If a top node is cleared, clear its dependent bottom node
                 clearNode(botNodes[topIdx]);
            } else if (botIdx !== -1) {
                 // If a bottom node is cleared, nothing else needs to be cleared.
            }
        }
        
        // Update flow button states based on data unavailability
        updateDownstreamFlows(rectId);
    });

    saveBtn?.addEventListener('click',e=>{
        e.stopPropagation();
        
        // Check if the node is empty, if so, nothing to save.
        if (rect.classList.contains('empty')) {
            console.warn(`Cannot save: ${rect.id} is empty.`);
            return;
        }
        
        // 1. Direct manual upload exists? Save it directly. (This handles all 'uploaded' nodes)
        if (originalFiles[rect.id]) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(originalFiles[rect.id]);
            a.download = originalFiles[rect.id].name;
            a.click();
            return;
        }
        
        // 2. No manual upload (i.e., it's a generated image)? Trace back to find source and process High Res.
        
        // Root Node should be handled by #1 (it's only populated by upload)
        if (rect.id === 'rootRect') return;

        // Top Row (Generated from Root)
        const topIdx = topNodes.findIndex(n => n.id === rect.id);
        if (topIdx !== -1) {
            if (originalFiles['rootRect']) {
                processHighResAndSave(originalFiles['rootRect'], 'channel', topIdx);
            }
            return;
        }

        // Bottom Row (Generated from Top Channel)
        const botIdx = botNodes.findIndex(n => n.id === rect.id);
        if (botIdx !== -1) {
            const channelIdx = botIdx; // Channel index is the same as botIdx
            
            // If Top Node has manual file, use that as source for grayscale processing
            const topNode = topNodes[botIdx];
            if (originalFiles[topNode.id]) {
                processHighResAndSave(originalFiles[topNode.id], 'grayscale', null);
            } 
            // If Top Node was generated, use the Root and apply BOTH filters (cascaded flow)
            else if (originalFiles['rootRect']) {
                processHighResAndSave(originalFiles['rootRect'], 'both', channelIdx);
            }
        }
    });
});
})();
</script>
</body>
</html>