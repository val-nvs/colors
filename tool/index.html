<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Dark Mode Bezier Layout - Image Processing</title>
<style>
/* Using 1rem = 16px conversion */
:root{--bg:#0b0f13;--panel:#0f1720;--muted:#94a3b8;--accent:#60a5fa;--inactive-flow:#475569;--active-flow:#facc15;}
*{box-sizing:border-box}
body{
  margin:0;
  padding:1.25rem; /* 20px -> 1.25rem */
  font-family:Inter,sans-serif;
  background:linear-gradient(180deg,var(--bg),#061018 120%);
  color:var(--muted);
  display:flex;
  justify-content:center;
  min-height: 100vh;
}
.container{max-width:68.75rem;width:100%} /* 1100px -> 68.75rem */
.card{
  background:linear-gradient(180deg,var(--panel),#0b1220);
  border-radius:0.75rem; /* 12px -> 0.75rem */
  padding:1rem; /* 16px -> 1rem */
  width: 100%;
}
/* Increased vertical spacing */
.top-wrap{display:flex;justify-content:center;margin:5rem 0} /* Increased from 3.75rem (60px) to 5rem (80px) */
.three-row{position:relative;margin:8rem 0} /* Increased from 6.25rem (100px) to 8rem (128px) */
.row{display:flex;gap:0.75rem;justify-content:space-between} /* 12px -> 0.75rem */
.bottom-row{margin-top:6rem} /* Increased from 5rem (80px) to 6rem (96px) */

/* Node Styling */
.rect,.node{
  /* Width is now flexible, adapting to container width via max-width */
  width:clamp(8rem, 31vw, 16.25rem); /* Flexible width, 260px is max */
  max-width: 31%;
  aspect-ratio:3/2;
  border-radius:0.75rem;
  background:#1e293b;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
  position:relative;
  transition:box-shadow 0.3s;
  flex-shrink: 1;
}
/* Only apply blue border if manually uploaded (controlled by JS toggling this class) */
.rect.uploaded,.node.uploaded{box-shadow:0 0 0 0.25rem rgba(96,165,250,0.6)} /* 4px -> 0.25rem */

/* Images are the only content in non-empty nodes */
.rect img, .node img {
    display: none; 
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: relative;
    z-index: 10;
}
.rect:not(.empty) img, .node:not(.empty) img {
    display: block; /* Show image only if not empty */
}


/* Buttons */
.upload-btn,.trash-btn,.save-btn{
  position:absolute;
  border:none;
  border-radius:0.25rem; /* 4px -> 0.25rem */
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  font-size:0.875rem; /* 14px -> 0.875rem */
  z-index:15; 
  transition: transform 0.1s, opacity 0.2s;
}
.upload-btn:active, .trash-btn:active, .save-btn:active {
    transform: scale(0.95);
}

.upload-btn{top:0.25rem;left:0.25rem;width:1.75rem;height:1.75rem;background:rgba(96,165,250,0.85);color:#fff} /* 4px, 28px -> 0.25rem, 1.75rem */
.trash-btn{top:0.25rem;right:0.25rem;width:1.75rem;height:1.75rem;background:rgba(248,113,113,0.85);color:#fff}

/* Flow Update Button (External to Node) - Always visible, state controlled by class */
.update-btn{
  position:absolute;
  width: 2rem; /* 32px -> 2rem */
  height: 2rem;
  color:#000;
  border-radius:50%;
  display:flex; 
  align-items:center;
  justify-content:center;
  font-size: 1rem; /* 16px -> 1rem */
  padding: 0;
  box-shadow: 0 0.125rem 0.25rem rgba(0,0,0,0.4); /* px -> rem */
  z-index: 20; 
  border: 0.1875rem solid var(--bg); /* 3px -> 0.1875rem */
  transition: background-color 0.2s, opacity 0.2s, transform 0.1s;
  cursor: pointer;
}
.update-btn.inactive {
  background-color: var(--inactive-flow);
  opacity: 0.6;
  cursor: default;
}
.update-btn:not(.inactive) {
  background-color: var(--active-flow);
  opacity: 1;
}
.update-btn:not(.inactive):hover {
    transform: scale(1.05);
}
.update-btn:not(.inactive):active {
    transform: scale(0.95);
}

.save-btn{bottom:0.25rem;right:0.25rem;width:1.75rem;height:1.75rem;background:rgba(34,197,94,0.85);color:#fff}

.three-row svg{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible;z-index: 1;}
input[type='file']{display:none}

/* Mobile Optimization for small screens (e.g., iPhone 8) */
@media (max-width: 480px) {
  body { padding: 0.5rem; } /* 8px -> 0.5rem */
  .card { padding: 0.625rem; } /* 10px -> 0.625rem */
  .top-wrap { margin: 1.5rem 0; } /* Adjusted spacing for mobile */
  .three-row { margin: 2rem 0; } /* Adjusted spacing for mobile */
  .bottom-row { margin-top: 1.5rem; } /* Adjusted spacing for mobile */
  
  .row { gap: 0.375rem; } /* 6px -> 0.375rem */
  
  .upload-btn, .trash-btn, .save-btn { width: 1.5rem; height: 1.5rem; font-size: 0.75rem; } /* 24px, 12px -> 1.5rem, 0.75rem */
  .update-btn { width: 1.75rem; height: 1.75rem; font-size: 0.875rem; } /* 28px, 14px -> 1.75rem, 0.875rem */
  
  .rect, .node {
    border-radius: 0.5rem; /* 8px -> 0.5rem */
    width: 32%; 
  }
}
</style>
</head>
<body>
<div class="container">
<div class="card">
<header><h1 style="color:var(--accent);font-size:1rem;margin:0;text-align:center;">Image Processing Layout</h1></header>
<section class="top-wrap">
<div id="rootRect" class="rect empty"><button class="upload-btn" title="Upload">ğŸ“¤</button><button class="trash-btn" title="Clear">ğŸ—‘ï¸</button><button class="save-btn" title="Save High-Res">ğŸ’¾</button><input type="file" accept="image/*"></div>
</section>
<section class="three-row" id="middleSection">
<svg id="linksSvg" aria-hidden="true"></svg>
<div class="row" id="topRow">
<div class="node empty" id="top1"><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="top2"><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="top3"><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
</div>
<div class="row bottom-row" id="bottomRow">
<div class="node empty" id="bot1"><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="bot2"><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
<div class="node empty" id="bot3"><button class="upload-btn">ğŸ“¤</button><button class="trash-btn">ğŸ—‘ï¸</button><button class="save-btn">ğŸ’¾</button><input type="file" accept="image/*"></div>
</div>
</section>
</div>
</div>
<script>
(function(){
const svg=document.getElementById('linksSvg');
const middleSection = document.getElementById('middleSection');
const rootRect = document.getElementById('rootRect');
// Dynamically get the currently rendered nodes to support non-3 rows
const topRow = document.getElementById('topRow');
const bottomRow = document.getElementById('bottomRow');
const topNodes = Array.from(topRow.querySelectorAll('.node'));
const botNodes = Array.from(bottomRow.querySelectorAll('.node'));
const allNodes = [rootRect, ...topNodes, ...botNodes];


// Store low-res canvases for display
let nodeCanvases={};
// Store original high-res files for saving
let originalFiles={};

function centerPoint(el){const rect=el.getBoundingClientRect();const parentRect=svg.getBoundingClientRect();return{x:rect.left+rect.width/2-parentRect.left,y:rect.top+rect.height/2-parentRect.top}}

function makePath(d){
    const p=document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('d',d);
    p.setAttribute('fill','none');
    p.setAttribute('stroke','rgba(96,165,250,0.85)');
    p.setAttribute('stroke-width','12'); 
    p.setAttribute('stroke-linecap','round');
    p.setAttribute('stroke-linejoin','round');
    return p
}

// Function to calculate the relative center point between two nodes
function getRelativeCenterCoords(sourceEl, targetEl) {
    const sRect = sourceEl.getBoundingClientRect();
    const tRect = targetEl.getBoundingClientRect();
    const containerRect = middleSection.getBoundingClientRect();
    
    // Midpoint Y in document coordinates
    const midY = (sRect.bottom + tRect.top) / 2;
    // Target X (center of the line entry) in document coordinates
    const targetEntryX = tRect.left + tRect.width / 2;
    
    // Convert to relative coordinates inside middleSection
    const relativeX = targetEntryX - containerRect.left;
    const relativeY = midY - containerRect.top;

    return { x: relativeX, y: relativeY };
}

function createFlowButton(targetId, x, y) {
    const buttonId = `flow-${targetId}`;
    let button = document.getElementById(buttonId);

    if (!button) {
        button = document.createElement('button');
        button.className = 'update-btn';
        button.id = buttonId;
        button.dataset.targetId = targetId;
        button.title = targetId.startsWith('top') ? "Process Channel" : "Process Grayscale";
        button.innerHTML = 'â¬‡ï¸';
        middleSection.appendChild(button);
        button.addEventListener('click', handleUpdateClick);
    }
    
    // Position the button based on calculated junction point, adjusted for button size (2rem = 32px)
    // 1rem (16px) for horizontal centering (32/2)
    // 1rem (16px) for vertical centering (32/2) - this positions the button's center at (x, y)
    button.style.cssText += `
        left: ${x - 16}px; 
        top: ${y - 16}px; 
    `;
    
    // Initial visibility check based on current state
    updateFlowButtonState(targetId);
}

function updateFlowButtonState(targetId) {
    const buttonId = `flow-${targetId}`;
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    const targetEl = document.getElementById(targetId);
    
    let sourceReady = false;
    const targetEmpty = targetEl.classList.contains('empty');
    
    // Determine the source readiness
    if (targetId.startsWith('top')) {
        // Source is 'rootRect'
        sourceReady = !!nodeCanvases['rootRect'];
    } else if (targetId.startsWith('bot')) {
        // Source is corresponding 'top' node
        const botIdx = botNodes.findIndex(n => n.id === targetId);
        const sourceId = topNodes[botIdx]?.id;
        sourceReady = !!nodeCanvases[sourceId];
    }
    
    // Button is ACTIVE (yellow) if source is ready AND target is empty
    if (sourceReady && targetEmpty) {
        button.classList.remove('inactive');
    } else {
        button.classList.add('inactive');
        if (button.innerHTML === 'âŒ' || button.innerHTML === 'âš™ï¸') {
             button.innerHTML = 'â¬‡ï¸';
        }
    }
}

function draw(){
    // 1. Clear and redraw Bezier curves
    while(svg.firstChild)svg.removeChild(svg.firstChild);
    const container=document.getElementById('middleSection');
    const box=container.getBoundingClientRect();
    svg.setAttribute('width',box.width);
    svg.setAttribute('height',box.height);
    svg.style.width=box.width+'px';
    svg.style.height=box.height+'px';
    
    const root=document.getElementById('rootRect');
    const rootRect=root.getBoundingClientRect();
    const svgRect=svg.getBoundingClientRect();
    
    const rootX=(rootRect.left+rootRect.width/2)-svgRect.left;
    const rootY=(rootRect.top+rootRect.height)-svgRect.top;
    
    // --- Draw Paths & Place Buttons for Root -> Top Row ---
    topNodes.forEach(n=>{
        const c=centerPoint(n);
        
        // 1. Calculate Button Center Coords (x_btn, y_btn)
        const coords = getRelativeCenterCoords(root, n); 
        const x_btn = coords.x;
        const y_btn = coords.y; 

        // Start and End of the overall path
        const startX=rootX;
        const startY=rootY;
        const endX=c.x;
        const endY=c.y-(n.getBoundingClientRect().height/2);
        
        // Vertical distance for the first segment (Root to Button)
        const distY1 = y_btn - startY;
        const V_OFFSET_1 = distY1 * 0.6; // 60% offset for graceful S-curve

        // --- Path 1: Root Bottom -> Button Center (Guaranteed vertical tangency at start/end) ---
        // CP1: X matches startX. CP2: X matches x_btn. This forces the vertical tangent.
        const cp1_1x = startX;
        const cp1_1y = startY + V_OFFSET_1; 
        const cp1_2x = x_btn;
        const cp1_2y = y_btn - V_OFFSET_1; 
        
        const d1=`M ${startX},${startY} C ${cp1_1x},${cp1_1y} ${cp1_2x},${cp1_2y} ${x_btn},${y_btn}`;
        svg.appendChild(makePath(d1));

        // Vertical distance for the second segment (Button to Node)
        const distY2 = y_btn - endY;
        const V_OFFSET_2 = distY2 * 0.6; // 60% offset for graceful S-curve

        // --- Path 2: Button Center -> Top Node Top (Guaranteed vertical tangency at start/end) ---
        // CP1: X matches x_btn. CP2: X matches endX.
        const cp2_1x = x_btn;
        const cp2_1y = y_btn - V_OFFSET_2; 
        const cp2_2x = endX;
        const cp2_2y = endY + V_OFFSET_2; 
        
        const d2=`M ${x_btn},${y_btn} C ${cp2_1x},${cp2_1y} ${cp2_2x},${cp2_2y} ${endX},${endY}`;
        svg.appendChild(makePath(d2));

        // Create the button at the midpoint
        createFlowButton(n.id, x_btn, y_btn);
    });

    // --- Draw Paths & Place Buttons for Top Row -> Bottom Row (Using smooth S-curve logic) ---
    const maxConnections = Math.min(topNodes.length, botNodes.length);

    for(let i=0;i<maxConnections;i++){
        const topN = topNodes[i];
        const botN = botNodes[i];

        const topC=centerPoint(topN);
        const bC=centerPoint(botN);

        // 1. Calculate Button Center Coords (x_btn, y_btn)
        const coords = getRelativeCenterCoords(topN, botN); 
        const x_btn = coords.x;
        const y_btn = coords.y; 
        
        // Start and End of the overall path
        const startX=topC.x;
        const startY=topN.getBoundingClientRect().bottom-svgRect.top;
        const endX=bC.x;
        const endY=botN.getBoundingClientRect().top-svgRect.top;
        
        // Vertical distance for the first segment (Top Node to Button)
        const distY1 = y_btn - startY;
        const V_OFFSET_1 = distY1 * 0.6; // 60% offset for graceful S-curve

        // --- Path 1: Top Node Bottom -> Button Center (Guaranteed vertical tangency at start/end) ---
        const cp1_1x=startX;
        const cp1_1y=startY + V_OFFSET_1;
        const cp1_2x=x_btn;
        const cp1_2y=y_btn - V_OFFSET_1; 
        
        const d1=`M ${startX},${startY} C ${cp1_1x},${cp1_1y} ${cp1_2x},${cp1_2y} ${x_btn},${y_btn}`;
        svg.appendChild(makePath(d1));

        // Vertical distance for the second segment (Button to Bottom Node)
        const distY2 = y_btn - endY;
        const V_OFFSET_2 = distY2 * 0.6; // 60% offset for graceful S-curve
        
        // --- Path 2: Button Center -> Bottom Node Top (Guaranteed vertical tangency at start/end) ---
        const cp2_1x=x_btn;
        const cp2_1y=y_btn - V_OFFSET_2;
        const cp2_2x=endX;
        const cp2_2y=endY + V_OFFSET_2;
        
        const d2=`M ${x_btn},${y_btn} C ${cp2_1x},${cp2_1y} ${cp2_2x},${cp2_2y} ${endX},${endY}`;
        svg.appendChild(makePath(d2));
        
        createFlowButton(botN.id, x_btn, y_btn);
    }
}

// Helper to clear a single node and update its flow state
function clearNode(nodeEl) {
    const rectId = nodeEl.id;
    const imgEl = nodeEl.querySelector('img');
    const input = nodeEl.querySelector('input[type=file]');

    imgEl.src = '';
    if (input) input.value = ''; 
    
    nodeEl.classList.add('empty');
    nodeEl.classList.remove('uploaded');
    
    delete nodeCanvases[rectId];
    delete originalFiles[rectId];

    // Update flow button leading to this node
    updateFlowButtonState(rectId);
}

// Helper to update downstream flow button states
function updateDownstreamFlows(rectId) {
    if(rectId === 'rootRect'){
        topNodes.forEach((n, idx) => {
            updateFlowButtonState(n.id); 
            if (botNodes[idx]) {
                updateFlowButtonState(botNodes[idx].id);
            }
        });
    } else {
        const topIdx = topNodes.findIndex(n => n.id === rectId);
        if (topIdx !== -1 && botNodes[topIdx]) {
            updateFlowButtonState(botNodes[topIdx].id);
        }
    }
}

async function handleUpdateClick(e) {
    e.stopPropagation();
    const button = e.currentTarget;
    const targetId = button.dataset.targetId;
    const rect = document.getElementById(targetId);
    
    if (button.classList.contains('inactive')) {
        return; 
    }
    
    let sourceCanvas = null;
    let isTopRow = false;
    let channelIdx = -1;
    
    if (targetId.startsWith('top')) {
        channelIdx = topNodes.findIndex(n => n.id === targetId);
        sourceCanvas = nodeCanvases['rootRect'];
        isTopRow = true;
    } else if (targetId.startsWith('bot')) {
        const botIdx = botNodes.findIndex(n => n.id === targetId);
        channelIdx = botIdx; 
        const sourceId = topNodes[botIdx]?.id;
        sourceCanvas = nodeCanvases[sourceId];
    }
    
    if(!sourceCanvas) return; 

    // Visual indication of work
    button.innerHTML = 'âš™ï¸'; 
    button.classList.add('inactive'); 
    
    const imgEl = rect.querySelector('img');
    let success = false;
    
    // Start processing (using low-res canvas)
    try {
        const ctx=sourceCanvas.getContext('2d');
        const imgData=ctx.getImageData(0,0,sourceCanvas.width,sourceCanvas.height);
        
        const newCanvas=document.createElement('canvas');
        newCanvas.width=sourceCanvas.width;
        newCanvas.height=sourceCanvas.height;
        const nctx=newCanvas.getContext('2d');
        const newData=nctx.createImageData(newCanvas.width,newCanvas.height);
        
        if (isTopRow) {
            // Process RGB Channels (R=0, G=1, B=2)
            for(let i=0;i<imgData.data.length;i+=4){
                newData.data[i+channelIdx]=imgData.data[i+channelIdx];
                if(channelIdx !== 0) newData.data[i]=0; 
                if(channelIdx !== 1) newData.data[i+1]=0;
                if(channelIdx !== 2) newData.data[i+2]=0;
                newData.data[i+3]=255; 
            }
        } else {
            // Process Grayscale (R=0, G=1, B=2) - Correctly use intensity of the specified channel only.
            const componentIndex = channelIdx; 
             for(let j=0;j<imgData.data.length;j+=4){
                const intensity = imgData.data[j + componentIndex]; 
                
                newData.data[j] = intensity;   
                newData.data[j+1] = intensity; 
                newData.data[j+2] = intensity; 
                newData.data[j+3] = 255;       
            }
        }

        nctx.putImageData(newData,0,0);
        
        imgEl.src = newCanvas.toDataURL();

        nodeCanvases[rect.id] = newCanvas;
        rect.classList.remove('empty'); 
        
        success = true;

    } catch (error) {
        console.error("Image processing failed:", error);
        button.innerHTML = 'âŒ'; 
    } finally {
        if (success) {
            button.innerHTML = 'â¬‡ï¸';
        }
        
        updateFlowButtonState(targetId);
        updateDownstreamFlows(targetId);
    }
}

function processHighResAndSave(file, type, channelIdx) {
    const reader = new FileReader();
    reader.onload = ev => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            
            // --- High-Res Processing Logic ---
            
            // 1. Apply Channel Filter (if applicable)
            if (type === 'channel' || type === 'both') {
                for(let i=0; i<data.length; i+=4) {
                    if (channelIdx !== 0) data[i] = 0;
                    if (channelIdx !== 1) data[i+1] = 0;
                    if (channelIdx !== 2) data[i+2] = 0;
                    data[i+3] = 255;
                }
            }

            // 2. Apply Grayscale Filter (if applicable)
            if (type === 'grayscale' || type === 'both') {
                const componentIndex = (type === 'both') ? channelIdx : null;
                for(let i=0; i<data.length; i+=4) {
                    let intensity;
                    if (componentIndex !== null) {
                        intensity = data[i + componentIndex]; 
                    } else {
                        intensity = (data[i] + data[i+1] + data[i+2]) / 3;
                    }
                    
                    data[i] = intensity;
                    data[i+1] = intensity;
                    data[i+2] = intensity;
                    data[i+3] = 255;
                }
            }

            ctx.putImageData(imgData, 0, 0);
            
            canvas.toBlob(blob => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `processed_highres_${Date.now()}.png`;
                a.click();
            }, 'image/png');
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
}

window.addEventListener('load',draw);
window.addEventListener('resize',()=>{if(window._drawRaf)cancelAnimationFrame(window._drawRaf);window._drawRaf=requestAnimationFrame(draw)});
setTimeout(draw,400);

allNodes.forEach(rect=>{
    const input=rect.querySelector('input[type=file]');
    const uploadBtn=rect.querySelector('.upload-btn');
    const trashBtn=rect.querySelector('.trash-btn');
    const saveBtn=rect.querySelector('.save-btn');
    
    // Create the persistent image element for display
    const imgEl=document.createElement('img');
    rect.appendChild(imgEl);
    
    uploadBtn?.addEventListener('click',e=>{e.stopPropagation();input.click()});
    
    input?.addEventListener('change',e=>{
        const file=e.target.files[0];
        if(!file)return;
        
        rect.classList.add('uploaded');
        
        const reader=new FileReader();
        reader.onload=ev=>{
            const tempImg = new Image();
            tempImg.onload = () => {
                const canvas=document.createElement('canvas');
                const ctx=canvas.getContext('2d');
                const maxW=400; 
                const scale=Math.min(maxW/tempImg.naturalWidth,maxW/tempImg.naturalHeight,1);
                canvas.width=tempImg.naturalWidth*scale;
                canvas.height=tempImg.naturalHeight*scale;
                ctx.drawImage(tempImg,0,0,canvas.width,canvas.height);
                
                imgEl.src=canvas.toDataURL('image/jpeg',0.8);
                
                nodeCanvases[rect.id]=canvas;
                originalFiles[rect.id]=file;
                rect.classList.remove('empty'); 
                
                // --- Cascade Updates on New Upload ---
                if(rect.id==='rootRect'){
                    // Update flow button states based on new data availability
                    updateFlowButtonState(rect.id);
                    updateDownstreamFlows(rect.id);
                } else {
                    const topIdx = topNodes.findIndex(n => n.id === rect.id);
                    if (topIdx !== -1) {
                         if (!botNodes[topIdx].classList.contains('uploaded')) {
                             clearNode(botNodes[topIdx]);
                         }
                    }
                    updateFlowButtonState(rect.id);
                    updateDownstreamFlows(rect.id);
                }
            };
            tempImg.src = ev.target.result; 
        };
        reader.readAsDataURL(file);
    });

    trashBtn?.addEventListener('click',e=>{
        e.stopPropagation();
        const rectId = rect.id;
        
        clearNode(rect);
        
        if(rectId === 'rootRect'){
            // Downstream flow buttons disabled
        } else {
            const topIdx = topNodes.findIndex(n => n.id === rect.id);
            if (topIdx !== -1) {
                 clearNode(botNodes[topIdx]);
            } 
        }
        
        updateDownstreamFlows(rectId);
    });

    saveBtn?.addEventListener('click',e=>{
        e.stopPropagation();
        
        if (rect.classList.contains('empty')) {
            console.warn(`Cannot save: ${rect.id} is empty.`);
            return;
        }
        
        if (originalFiles[rect.id]) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(originalFiles[rect.id]);
            a.download = originalFiles[rect.id].name;
            a.click();
            return;
        }
        
        if (rect.id === 'rootRect') return;

        const topIdx = topNodes.findIndex(n => n.id === rect.id);
        if (topIdx !== -1) {
            if (originalFiles['rootRect']) {
                processHighResAndSave(originalFiles['rootRect'], 'channel', topIdx);
            }
            return;
        }

        const botIdx = botNodes.findIndex(n => n.id === rect.id);
        if (botIdx !== -1) {
            const channelIdx = botIdx; 
            const topNode = topNodes[botIdx];
            if (originalFiles[topNode.id]) {
                processHighResAndSave(originalFiles[topNode.id], 'grayscale', null);
            } 
            else if (originalFiles['rootRect']) {
                processHighResAndSave(originalFiles['rootRect'], 'both', channelIdx);
            }
        }
    });
});
})();
</script>
</body>
</html>