<!DOCTYPE html>
<html>
<head>
  <style>
    /*── Viewport & no scrollbars ────────────────────────────────*/
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: black;
      color: white;
      display: flex;
      flex-direction: column;
    }
    #controls {
      flex: 0 0 auto;
      padding: 8px;
      text-align: center;
      z-index: 1;
    }
    #canvas-container {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      padding-top: 16px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="controls">
    <input id="hueL" type="range" min="-179" max="180" value="0">
    <span id="hueLval">0°</span>
    <input id="hueM" type="range" min="0" max="359" value="180">
    <span id="hueMval">180°</span>
    <input type="file" id="imgInput" accept="image/*">
  </div>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const canvas    = document.getElementById('canvas');
      const ctx       = canvas.getContext('2d');
      const fileInput = document.getElementById('imgInput');
      const hueLInput = document.getElementById('hueL');
      const hueMInput = document.getElementById('hueM');
      const hueLVal   = document.getElementById('hueLval');
      const hueMVal   = document.getElementById('hueMval');
      let lastImg = null;

      // HSV → RGB (0–255)
      function hsv2rgb(h, s, v) {
        h = ((h % 360) + 360) % 360;
        const c = v * s;
        const hp = h / 60;
        const x = c * (1 - Math.abs((hp % 2) - 1));
        let [r1, g1, b1] = [0, 0, 0];
        if (hp < 1)       [r1, g1, b1] = [c, x, 0];
        else if (hp < 2)  [r1, g1, b1] = [x, c, 0];
        else if (hp < 3)  [r1, g1, b1] = [0, c, x];
        else if (hp < 4)  [r1, g1, b1] = [0, x, c];
        else if (hp < 5)  [r1, g1, b1] = [x, 0, c];
        else              [r1, g1, b1] = [c, 0, x];
        const m = v - c;
        return { r: (r1 + m) * 255, g: (g1 + m) * 255, b: (b1 + m) * 255 };
      }

      // Normalize so r+g+b = 255
      function normalize255({r, g, b}) {
        const sum = r + g + b;
        if (sum === 0) return { r:0, g:0, b:0 };
        const f = 255 / sum;
        return { r: r*f, g: g*f, b: b*f };
      }

      // Compute overlay colors from sliders,
      // mapping second slider linearly to [120°,240°] relative to first
      function computeOverlays() {
        const rawL = +hueLInput.value;
        const rawM = +hueMInput.value;
        const hueL = ((rawL % 360) + 360) % 360; // Wrap to [0–359]

        // map rawM [0,359] → delta [120,240]
        const t = rawM / 359;                 // [0,1]
        const delta = 120 + t * 120;          // [120,240]
        const effM = (hueL + delta) % 360;    // effective second hue

        // update labels
        hueLVal.textContent = hueL + '°';
        hueMVal.textContent = (effM.toFixed(0)) + '°';

        const oL = normalize255(hsv2rgb(hueL,1,1));
        const oM = normalize255(hsv2rgb(effM,1,1));
        const rawS = {
          r: Math.max(0,255 - oL.r - oM.r),
          g: Math.max(0,255 - oL.g - oM.g),
          b: Math.max(0,255 - oL.b - oM.b)
        };
        const oS = normalize255(rawS);
        return { oL, oM, oS };
      }

      // Apply hue filter on buffer
      function applyHueOverlays() {
        const { oL, oM, oS } = computeOverlays();
        const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
        const d = imgData.data;
        for (let i=0; i<d.length; i+=4) {
          const L = d[i], M = d[i+1], S = (L + M)/2;
          const tint = (v,o) => ({ r:o.r*(v/255), g:o.g*(v/255), b:o.b*(v/255) });
          const tL = tint(L,oL), tM = tint(M,oM), tS = tint(S,oS);
          let r = tL.r + tM.r + tS.r;
          let g = tL.g + tM.g + tS.g;
          let b = tL.b + tM.b + tS.b;
          d[i]   = r>255?255:r;
          d[i+1] = g>255?255:g;
          d[i+2] = b>255?255:b;
        }
        ctx.putImageData(imgData,0,0);
      }

      // Redraw image to fit and filter
      function redraw() {
        if (!lastImg) return;
        const availW = window.innerWidth;
        const availH = window.innerHeight - document.getElementById('controls').offsetHeight - 16;
        const scale = Math.min(availW/lastImg.width, availH/lastImg.height);
        const dispW = lastImg.width * scale;
        const dispH = lastImg.height * scale;

        canvas.style.width  = dispW + 'px';
        canvas.style.height = dispH + 'px';

        const dpr = window.devicePixelRatio || 1;
        canvas.width  = dispW * dpr;
        canvas.height = dispH * dpr;

        ctx.drawImage(lastImg,0,0,canvas.width,canvas.height);
        applyHueOverlays();
      }

      // Load image
      fileInput.addEventListener('change', () => {
        const file = fileInput.files[0]; if (!file) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { lastImg = img; URL.revokeObjectURL(url); redraw(); };
        img.src = url;
      });

      // Update on slider & resize
      hueLInput.addEventListener('input', redraw);
      hueMInput.addEventListener('input', redraw);
      window.addEventListener('resize', redraw);
    });
  </script>
</body>
</html>